# Conventions

Our global conventions.

____
# Overall

### Ports numbering

We want to avoid conflicts between the ports used by our apps.
- Backend apps should listen on ports 5xxx
- Frontend apps should listen on ports 3xxx
- Listening port should be unique across all projects

____
# Infrastructure

### Logging

For both backend & frontend services: logs must be structured the same way everywhere and must be in compliance with to our specification:

We use **JSON** to format our logs.

All following sections are on same level of the JSON object, we just split them by section to explain what are their purposes.

### Adding more fields

Everytime a new field is required, we must check it does not fit into an existing one to keep consistency between different services.
Each new fields should be added in this documentation.

#### About the receiver:
*Information related to the machine/server/service receiving an instruction.*

```json
{
  "host": "172.0.0.1,198.0.0.1...",
  "service_name": "nginx,auth-backend,hydra,admin-frontend...",
  "service_version": "version of the service",
  "local_date": "UTC date in RFC3339 format: 2002-10-02T15:00:00.05Z",
}
```

**Mandatory fields:** `host`, `service_name`, `service_version`, `local_date`.

#### About the received request:
*Information related to received intruction.*

```json
{
  "request_id": "request unique identifier: anything unique generated by first interlocutor",
  "requester": "entity performing the request: app:uuid/service:name/user:uuid...",
  "protocol": "used communication protocol: http,gRPC...",
  "uri_path": "location of the request: /user-accounts,...",
  "method": "use method for the request: GET,POST...",
  "request_bytes": "size of the received body",
}
```

**Mandatory fields:** `request_id`, `requester`.

#### About the response:
*Information about the response done by the service.*

``` json
{
  "status": "response code",
  "response_bytes": "size of returned body",
  "response_time": "amount of time to process the request",
  "message": "free text",
}
```

**No mandatory fields.**

#### About the log itself:
*Information about the log.*

```json
{
  "severity": "level of the log: debug/info/critical...",
  "file": "file where the logging happened",
  "line_no": "the line where the logging happened",
  "stack_trace": "free text about the stack trace of the program",
}
```

**Mandatory fields:**: `severity`, `file`, `no_line`.

____
# Backend

## HTTP

All HTTP responses should set a valid HTTP code that fits the reality of the response.
If you have a doubt on which code to use, feel free to ask!

## Error conventions

Backend errors follow these two conventions:

Return the HTTP error code that fits.

Return a JSON object of this shape:
```json
{
     "code": "{Code}",
     "desc": "free format description",
     "origin": "{Origin}",
     "details": {
       "{DetailKey}": "{DetailValue}",
       "{DetailKey}": "{DetailValue}",
     },
}
```

All "{things}" are described in following sections...

### Code

Code describes an error code as a string used internally and by clearer consumer for better error identifications & reactions.

It represents global codes and corresponds to http status as described [here](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).

We use this link as general specifications for errors and not just for http request errors.

**Classic codes:** _codes corresponding to http status codes_
* `bad_request`: 400, general bad request.
* `unauthorized`: 401, a required valid token is missing/malformed/expired.
* `forbidden`: 403, accesses checks failed.
* `not_found`: 404, the resource/route has been not found.
* `method_not_allowed`: 405, the method is not supported at a resource.
* `conflict`: 409, the action cannot be perform of the resource.
* `unprocessable_entity`: 422, the received entity is unprocessable.
* `internal`: 500, something internal to the service has failed.
* `...`

**Redirect codes**: _code encountered in query parameter `error_code` on redirections_
* `invalid_flow`
* `invalid_url`
* `missing_parameter`
* `forbidden_role`
* `auth_process_required`
* `...`

**Special codes:** _special codes that should not be encountered externally_
/!\ Thanks to contact the backend team if you receive one these codes.
* `unknown_code`: 500, something internal to the service has failed.
* `no_code`: xxx, no specific code defined.

### Origin
Origin is an information about where the error does come from.

**Possible origins:**
* `body`: comes from body parameter.
* `query`: comes from query parameters.
* `path`: comes from path parameters.
* `headers`: comes from headers.
* `internal`: comes from internal logic.
* `...`

**Special origins:** _special origins that should not be encountered externally_
/!\ Thanks to contact the backend team if you receive one these origins.
* `not_defined`: the error has no origin defined yet

### Details

An object containing a dynamical number of detail objects.

Each detail object is built with a DetailKey and a DetailValue:

-> A DetailKey is an dynamical string representing fields name, query parameters name, resource identifiers...

-> A DetailValue describes an error code as a string for clearer consumer error identification & reactions. It represents codes related to a detail key.

**Possible detail values:**

* `conflict`: unique...
* `malformed`: email format,  ip address format...
* `invalid`: minumum/maximum value/lenght...
* `required`: missing in request...
* `expired`: expired duration...
* `forbidden`: forbidden to update...
* `internal`: internal error occured
* `locked`: cannot be updated
* `not_found`: correspondance has not been found
* `not_supported`: not handled by the running implementation
* `timed_out`: something... timed out
* `unauthorized`: authorization is missing

**Special detail values:**
/!\ Thanks to contact the backend team if you receive one these detail values.
* `unknown`: unknown detail code
* `no_code`: no specific code

:warning: In rare cases, the detail is used to give more information about an expected, required value or an resource identifier to allow a deeper error handling on consumer side.
In this case, an normal formatted detail about the field goes along with this information to give more context and to still be processed in a generic way if wished.

Example:

`On user backup update`:
```json
    "details": {
        "version": "conflict",
        "expected_version": "1"
    }
```

`On any authenticated routes`:
```json
    "details": {
        "acr" conflict",
        "required_acr": "2"
    }
```


## API Format

For each API that don't need to follow a specific standard (like OAuth for the authentication), we aim to implement resource-oriented apis.

We target to be RESTful but we could make some exceptions according to our needs. Exceptions must be discussed and agreed between maintainers to ensure APIs can evolve decently, and so architecture and product.

You can read about resource-oriented good pratices in the [Google API Design Guide](https://cloud.google.com/apis/design/).

## Emailing

All email we send should follow email's RFC.
Particulary we should implement an HTML and a plain text version of the content

## Internationalization (I18N)

Most of the I18N should be done in frontend. So the backend will send to frontend translation labels.
For the few cases that are not working in frontend (like sending emails), the I18N should be possible too (and as much as possible the language should be defined by the frontend).

____
# Frontend

We use I18Next as a frontend I18N framework. \o/
